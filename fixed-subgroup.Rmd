---
title: "Plaque psoriasis ML-NMR"
output:
  pdf_document:
    latex_engine: lualatex
fontsize: 12pt
mainfont: Arial
linestretch: 1.5
---

```{r, include=FALSE}
# Secukinumab (司库奇尤单抗, Novartis, IL blocker)
# Etanercept (依那西普, Pfizer, TNFa blocker)
# Ustekinumab (乌司奴单抗, J&J, IL blocker)                       
# Ixekizumab (依克珠单抗, EliLilly, IL blocker)





```

1. In the "FIXTURE" trial, the Secukinumab is more effective than Etanercept. (300 mg Secukinumab vs 150 mg Secukinumab vs Placebo vs 50mg etanercept)

2. In the "ERASURE" trial, 300 mg Secukinumab vs 150 mg Secukinumab vs Placebo. 



### IPD
1. In the "IXORA" trial, Ixekizumab vs Ustekinumab.


2. In the "UNCOVER-1" trial, 80 mg ixekizumab p2w vs 160 mg ixekizumab p2w vs 80 mg ixekizumab p4w.

3. In the "UNCOVER-2" trial, 80 mg ixekizumab p2w vs 160 mg ixekizumab p2w vs 80 mg ixekizumab p4w vs 50 mg etanercept

4. In the "UNCOVER-3" trial, 80 mg ixekizumab p2w vs 160 mg ixekizumab p2w vs 80 mg ixekizumab p4w vs 50 mg etanercept

5. From the "UNCOVER-2" and "UNCOVER-3", ixekizumab is more effective than Etanercept.



```{r, warning=FALSE, echo=FALSE}
library(multinma)
library(dplyr)      # dplyr and tidyr for data manipulation
library(tidyr)
library(ggplot2)    # ggplot2 for plotting covariate distributions

options(mc.cores = parallel::detectCores())

nc <- switch(tolower(Sys.getenv("_R_CHECK_LIMIT_CORES_")), 
             "true" =, "warn" = 2, 
             parallel::detectCores())
options(mc.cores = nc)
```


## Acquire IPD and AGD
```{r}
full_ipd <- plaque_psoriasis_ipd

full_agd <- plaque_psoriasis_agd

pso_ipd <- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-2"))

pso_agd <- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

```

## check the age distribution of IPD data
```{r, warning=FALSE, echo=FALSE}
hist(full_ipd$age)
summary(full_ipd$age)
```

The distribution is pretty normal. 

```{r}
pso_ipd <- pso_ipd %>% 
  mutate(# Variable transformations
         bsa = bsa / 100,
         prevsys = as.numeric(prevsys),
         psa = as.numeric(psa),
         weight = weight / 10,
         durnpso = durnpso / 10,
         # Treatment classes
         trtclass = case_when(trtn == 1 ~ "Placebo",
                              trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                              trtn == 4 ~ "TNFa blocker"),
         # Check complete cases for covariates of interest
         complete = complete.cases(durnpso, prevsys, bsa, weight, psa),
         sub_g = ifelse(age>=47, "gt or eq 47", "lt 47"))


## five covariate durnpso, prevsys, bsa, weight, psa
## calculate the mean age in younger and older group
sub <- pso_ipd %>% 
  mutate(sub_g = ifelse(age>=47, "gt or eq 47", "lt 47")) %>%
  group_by(sub_g) %>% 
  summarise(age_mean = mean(age),
            age_sd = sd(age))

pso_sbg <- pso_ipd %>% 
  group_by(studyc, sub_g) %>%
  # group_by(studyc, sub_g, trtc, trtclass) %>% 
  summarise(age_mean = mean(age),
            age_sd = sd(age),
            bmi_mean = mean(bmi, na.rm = TRUE),
            bmi_sd = sd(bmi, na.rm = TRUE),
            weight_mean = mean(bmi, na.rm = TRUE),
            weight_sd = sd(bmi, na.rm = TRUE),
            durnpso_mean = mean(durnpso),
            durnpso_sd = sd(durnpso),
            pasi75_n = n(),
            pasi75_r = sum(pasi75),
            pasi90_n = n(),
            pasi90_r = sum(pasi90),
            pasi100_n = n(),
            pasi100_r = sum(pasi100), 
            psa = mean(psa), 
            prevsys = mean(prevsys), 
            bsa_mean = mean(bsa), 
            bsa_sd = sd(bsa)) %>%
  mutate(
    # trtc = paste0(sub_g," ",trtclass, " ", trtc),
         trtc = sub_g,
         studyc = paste(studyc, " Sub"))%>%
    ungroup() %>%
    select(-sub_g)

## include studyc, trt, trtclass into by vars            
pso_sbg2 <- pso_ipd %>% 
  group_by(studyc, sub_g, trtclass) %>%
  summarise(age_mean = mean(age),
            age_sd = sd(age),
            bmi_mean = mean(bmi, na.rm = TRUE),
            bmi_sd = sd(bmi, na.rm = TRUE),
            weight_mean = mean(bmi, na.rm = TRUE),
            weight_sd = sd(bmi, na.rm = TRUE),
            durnpso_mean = mean(durnpso),
            durnpso_sd = sd(durnpso),
            pasi75_n = n(),
            pasi75_r = sum(pasi75),
            pasi90_n = n(),
            pasi90_r = sum(pasi90),
            pasi100_n = n(),
            pasi100_r = sum(pasi100), 
            psa = mean(psa), 
            prevsys = mean(prevsys), 
            bsa_mean = mean(bsa), 
            bsa_sd = sd(bsa)) %>%
  mutate(
    trtc = paste0(sub_g," ",trtclass),
         studyc = paste(studyc, " Sub"))%>%
    ungroup() %>%
    select(-sub_g)



pso_agd <- pso_agd %>% 
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                              trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                              trtn == 4 ~ "TNFa blocker")
  )

# combine the AGD and subgroup
pso_agd2 <- bind_rows(pso_agd,
                      pso_sbg)

pso_agd3 <- bind_rows(pso_agd,
                      pso_sbg2)
```

A small number of individuals have missing covariates:
```{r}
sum(!pso_ipd$complete)
mean(!pso_ipd$complete)
```

Since the proportion of missing data is so small, we will simply exclude these individuals from the analysis.
```{r}
pso_ipd <- filter(pso_ipd, complete)
```

## Creating the network

```{r}

pso_net_sub <- combine_network(
  set_ipd(pso_ipd, 
          study = studyc, 
          trt = trtc, 
          r = pasi75),
          # ,
          # trt_class = trtclass),
  
  set_agd_arm(pso_agd2, 
              study = studyc, 
              trt = trtc, 
              r = pasi75_r, 
              n = pasi75_n)
          #     ,
          # trt_class = trtclass)
)

pso_net_sub1 <- combine_network(
  set_ipd(pso_ipd, 
          study = studyc, 
          trt = trtc, 
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd3, 
              study = studyc, 
              trt = trtc, 
              r = pasi75_r, 
              n = pasi75_n,
              trt_class = trtclass)
)

pso_net <- combine_network(
  set_ipd(pso_ipd, 
          study = studyc, 
          trt = trtc, 
          r = pasi75,
          trt_class = trtclass),
  
  set_agd_arm(pso_agd, 
              study = studyc, 
              trt = trtc, 
              r = pasi75_r, 
              n = pasi75_n,
          trt_class = trtclass)
)

pso_net

```

We can produce a network plot with the `plot()` method:
```{r pso_network_plot, fig.width=8, fig.height=6, out.width="100%"}
plot(pso_net_sub, weight_nodes = TRUE, weight_edges = TRUE, show_trt_class = F) + 
  ggplot2::theme(legend.position = "bottom", legend.box = "vertical")

plot(pso_net_sub1, weight_nodes = TRUE, weight_edges = TRUE, show_trt_class = F) + 
  ggplot2::theme(legend.position = "bottom", legend.box = "vertical")

plot(pso_net, weight_nodes = TRUE, weight_edges = TRUE, show_trt_class = T) + 
  ggplot2::theme(legend.position = "bottom", legend.box = "vertical")
```

## Numerical integration for ML-NMR

```{r pso_covariate_plot}
# Get mean and sd of covariates in each study
ipd_summary <- pso_ipd %>% 
  group_by(studyc) %>% 
  summarise_at(vars(weight, durnpso, bsa), list(mean = mean, sd = sd, min = min, max = max)) %>% 
  pivot_longer(weight_mean:bsa_max, names_sep = "_", names_to = c("covariate", ".value")) %>% 
  # Assign distributions
  mutate(dist = recode(covariate,
                       bsa = "dlogitnorm",
                       durnpso = "dgamma",
                       weight = "dgamma")) %>% 
  # Compute density curves
  group_by(studyc, covariate) %>% 
  mutate(value = if_else(dist == "dlogitnorm",
                         list(seq(0, 1, length.out = 101)),
                         list(seq(min*0.8, max*1.2, length.out = 101)))) %>% 
  unnest(cols = value) %>% 
  mutate(dens = eval(call(first(dist), x = value, mean = first(mean), sd = first(sd))))

# Plot histograms and assumed densities
pso_ipd %>% 
  pivot_longer(c(weight, durnpso, bsa), names_to = "covariate", values_to = "value") %>% 
ggplot(aes(x = value)) +
  geom_histogram(aes(y = stat(density)), 
                 binwidth = function(x) diff(range(x)) / nclass.Sturges(x),
                 boundary = 0,
                 fill = "grey50") +
  geom_line(aes(y = dens), data = ipd_summary,
            colour = "darkred", size = 0.5) +
  facet_wrap(~studyc + covariate, scales = "free", ncol = 3) +
  theme_multinma()
```


```{r}
pso_net_org <- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 1000
)

pso_net_sub <- add_integration(pso_net_sub,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 1000
)

pso_net_sub1 <- add_integration(pso_net_sub1,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 1000
)

pso_net1 <- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  age = distr(qnorm, mean = 55.98142, sd = 7.645212),
  n_int = 1000
)

pso_net <- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  age = distr(qnorm, mean = 34.99825, sd = 7.104982),
  n_int = 1000
)

pso_net1 <- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  age = distr(qnorm, mean = 55.98142, sd = 7.645212),
  n_int = 1000
)
```

# ML-NMR models
We fit both fixed effect (FE) and random effects (RE) ML-NMR models.

## Fixed effect ML-NMR

```{r}
summary(normal(scale = 10))
```


```{r}

set.seed(111111)
pso_fit_FE_sub <- nma(pso_net_sub, 
                  trt_effects = "fixed",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  init_r = 0.1,
                  QR = TRUE)

## failed to get the chain
pso_fit_FE_sub1 <- nma(pso_net_sub1, 
                  trt_effects = "fixed",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  init_r = 0.1,
                  QR = TRUE)


pso_fit_FE <- nma(pso_net, 
                  trt_effects = "fixed",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa + age)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  init_r = 0.1,
                  QR = TRUE)

pso_fit_FE1 <- nma(pso_net1, 
                  trt_effects = "fixed",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa + age)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  init_r = 0.1,
                  QR = TRUE)

pso_fit_FE_org <- nma(pso_net_org, 
                  trt_effects = "fixed",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  init_r = 0.1,
                  QR = TRUE)
```

Basic parameter summaries are given by the `print()` method:
```{r}
print(pso_fit_FE_sub1)

print(pso_fit_FE)

print(pso_fit_FE1)

```

By default, summaries of the study-specific intercepts $\mu_j$ are hidden, but could be examined by changing the `pars` argument:
```{r, eval=FALSE}
# Not run
print(pso_fit_FE, pars = c("d", "beta", "mu"))
```

The prior and posterior distributions can be compared visually using the `plot_prior_posterior()` function:
```{r pso_FE_pp_plot, fig.width=8, fig.height=6, out.width="100%"}
plot_prior_posterior(pso_fit_FE, prior = c("intercept", "trt", "reg"))
```

Plots of estimated numerical integration error are produced using the `plot_integration_error()` function:
```{r pso_FE_cumint}
plot_integration_error(pso_fit_FE)
```

## Random effects ML-NMR
We now fit a RE model.
Again, we specify weakly-informative $N(0, 10^2)$ priors on each parameter, and now specify a $\textrm{half-N}(0, 2.5^2)$ prior for the heterogeneity standard deviation $\tau$.
The range of parameter values implied by these prior distributions can be checked using the `summary()` method:
```{r}
summary(normal(scale = 10))
summary(half_normal(scale = 2.5))
```

Fitting the model uses the same call to `nma()` as before, except now with `trt_effects = "random"`.
```{r, eval=!params$run_tests}
pso_fit_RE <- nma(pso_net, 
                  trt_effects = "random",
                  link = "probit", 
                  likelihood = "bernoulli2",
                  regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
                  class_interactions = "common",
                  prior_intercept = normal(scale = 10),
                  prior_trt = normal(scale = 10),
                  prior_reg = normal(scale = 10),
                  prior_het = half_normal(scale = 2.5),
                  init_r = 0.1,
                  QR = TRUE)


?nma

```

Basic parameter summaries are given by the `print()` method:
```{r, eval=!params$run_tests}
print(pso_fit_RE)
```

By default, summaries of the study-specific intercepts $\mu_j$ and study-specific relative effects $\delta_{jk}$ are hidden, but could be examined by changing the `pars` argument:
```{r, eval=FALSE}
# Not run
print(pso_fit_RE, pars = c("d", "beta", "tau", "mu", "delta"))
```

There are a number of divergent transitions, which we can investigate using the `pairs()` method:
```{r pso_RE_pairs, eval=!params$run_tests}
pairs(pso_fit_RE, pars = c("delta[UNCOVER-2: ETN]", "d[ETN]", "tau", "lp__"))
```

The divergent transition errors (red crosses) seem to be concentrated in the upper tail of the heterogeneity standard deviation parameter.
This suggests that the information to identify the heterogeneity parameter is weak - we have only four studies in the network - and that a more informative prior distribution might aid estimation.

The prior and posterior distributions can be compared visually using the `plot_prior_posterior()` function:
```{r pso_RE_pp_plot, eval=!params$run_tests, fig.width=8, fig.height=6, out.width="100%"}
plot_prior_posterior(pso_fit_RE, prior = c("intercept", "trt", "reg", "het"))
```

Plots of estimated numerical integration error are produced using the `plot_integration_error()` function:
```{r pso_RE_cumint, eval=!params$run_tests}
plot_integration_error(pso_fit_RE)
```

# Model comparison
The model fit under the FE and RE models can be checked using the `dic()` function.
```{r, eval=!params$run_tests}
(pso_dic_FE <- dic(pso_fit_FE))
(pso_dic_RE <- dic(pso_fit_RE))
```
```{r, eval=params$run_tests, echo=FALSE}
(pso_dic_FE <- dic(pso_fit_FE))
```

The DIC is similar between the FE and RE models, suggesting that there is little evidence for any residual heterogeneity.

# Further results
Parameter estimates can be plotted using the `plot()` method, for example to examine the estimated regression coefficients:
```{r}
plot(pso_fit_FE,
     pars = "beta",
     stat = "halfeye",
     ref_line = 0)
```

Plots of posterior summaries are based on the `ggdist` package, which allows a great degree of flexibility, and can be further customised using `ggplot2` commands. 
In the above command we specify a `"halfeye"` plot, which shows the posterior density along with posterior medians (points) and 95% Credible Intervals (thin line) with 66% inner bands (thicker line) by default.
For more details on the plotting options see `?plot.nma_summary`.

We can produce population-adjusted relative effects for each study population in the network using the `relative_effects()` function.
```{r pso_releff_FE}
(pso_releff_FE <- relative_effects(pso_fit_FE))
plot(pso_releff_FE, ref_line = 0)
```

Predicted probabilities of achieving PASI 75 in each study population on each treatment are produced using the `predict()` method.
The argument `type = "reponse"` specifies that we want predicted probabilities, rather than probit probabilities.
```{r pso_pred_FE}
(pso_pred_FE <- predict(pso_fit_FE, type = "response"))
plot(pso_pred_FE, ref_line = c(0, 1))
```

We can produce population-adjusted ranks, rank probabilities, and cumulative rank probabilities in each study population using the `posterior_ranks()` and `posterior_rank_probs()` functions (although here the ranks are unchanged between populations, as the distributions of effect modifiers are similar).
We specify `lower_better = FALSE`, since a higher outcome is better (higher chance of achieving PASI 75).
```{r pso_ranks_FE}
(pso_ranks_FE <- posterior_ranks(pso_fit_FE, lower_better = FALSE))
plot(pso_ranks_FE)
```

```{r pso_rankprobs_FE}
(pso_rankprobs_FE <- posterior_rank_probs(pso_fit_FE, lower_better = FALSE))
plot(pso_rankprobs_FE)
```

```{r pso_cumrankprobs_FE}
(pso_cumrankprobs_FE <- posterior_rank_probs(pso_fit_FE, lower_better = FALSE, cumulative = TRUE))
plot(pso_cumrankprobs_FE)
```

All of the above estimates (relative effects, predictions, rankings) can also be produced for a specific target population or populations by providing a suitable `newdata` argument to for function (and a `baseline` distribution for `predict()`).

To produce population-adjusted relative effects (and corresponding rankings) for a chosen target population, we require only the mean covariate values in that population.
For example, `newdata` could provide the following mean covariate values:
```{r}
new_agd_means <- tibble(
  bsa = 0.6,
  prevsys = 0.1,
  psa = 0.2,
  weight = 10,
  durnpso = 3)
```

Population-adjusted relative effects in this target population are then calculated using the `relative_effects()` function, and can be plotted with the corresponding `plot()` method:
```{r pso_releff_FE_new}
(pso_releff_FE_new <- relative_effects(pso_fit_FE, newdata = new_agd_means))
plot(pso_releff_FE_new, ref_line = 0)
```

For absolute predictions, we require information about the full covariate distribution in the target population, not just the mean values.
If IPD are available for the target population, `newdata` is simply a data frame of the IPD.
If AgD are available for the target population, `newdata` must be a data frame with added integration points created using the `add_integration()` function.
 
For example, suppose the aggregate target population introduced above had the following covariate means and standard deviations (for continuous covariates) or proportions (for discrete covariates):
```{r}
new_agd_int <- tibble(
  bsa_mean = 0.6,
  bsa_sd = 0.3,
  prevsys = 0.1,
  psa = 0.2,
  weight_mean = 10,
  weight_sd = 1,
  durnpso_mean = 3,
  durnpso_sd = 1
)
```

We add integration points to this data frame in a similar manner to before.
Again, we need to supply a correlation matrix for the joint covariate distribution; we use the same weighted mean correlation matrix computed earlier from the IPD in the network, which is stored in the network object as `int_cor`.
```{r}
new_agd_int <- add_integration(new_agd_int,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  cor = pso_net$int_cor,
  n_int = 1000)
```

Predicted probabilities of achieving PASI 75 in this target population, given a $N(-1.75, 0.08^2)$ distribution on the baseline probit-probability of response on Placebo (at the reference levels of the covariates), are then produced using the `predict()` method:
```{r pso_pred_FE_new}
(pso_pred_FE_new <- predict(pso_fit_FE, 
                            type = "response",
                            newdata = new_agd_int,
                            baseline = distr(qnorm, -1.75, 0.08)))
plot(pso_pred_FE_new, ref_line = c(0, 1))
```

# References

```{r pso_tests, include=FALSE, eval=params$run_tests}
library(testthat)
library(dplyr)

tol <- 0.05
tol_dic <- 0.1

# FE model parameters
test_fe <- tribble(
  ~parameter                            , ~mean, ~sd , ~`2.5%`, ~`50%`, ~`97.5%`,
  "beta[durnpso]"                       , 0.05 , 0.06, -0.08  , 0.05  , 0.17    ,
  "beta[prevsys]"                       , -0.13, 0.16, -0.44  , -0.13 , 0.17    ,
  "beta[bsa]"                           , -0.06, 0.45, -0.98  , -0.05 , 0.78    ,
  "beta[weight]"                        , 0.04 , 0.03, -0.02  , 0.04  , 0.10    ,
  "beta[psa]"                           , -0.08, 0.17, -0.42  , -0.08 , 0.25    ,
  "beta[durnpso:.trtclassTNFa blocker]", -0.03, 0.08, -0.18  , -0.03 , 0.12    ,
  "beta[durnpso:.trtclassIL blocker]"  , -0.01, 0.07, -0.15  , -0.01 , 0.12    ,
  "beta[prevsys:.trtclassTNFa blocker]", 0.19 , 0.19, -0.19  , 0.19  , 0.56    ,
  "beta[prevsys:.trtclassIL blocker]"  , 0.06 , 0.17, -0.28  , 0.06  , 0.40    ,
  "beta[bsa:.trtclassTNFa blocker]"    , 0.05 , 0.52, -0.95  , 0.04  , 1.10    ,
  "beta[bsa:.trtclassIL blocker]"      , 0.29 , 0.49, -0.64  , 0.29  , 1.27    ,
  "beta[weight:.trtclassTNFa blocker]" , -0.17, 0.04, -0.23  , -0.17 , -0.10   ,
  "beta[weight:.trtclassIL blocker]"   , -0.10, 0.03, -0.16  , -0.10 , -0.03   ,
  "beta[psa:.trtclassTNFa blocker]"    , -0.06, 0.21, -0.46  , -0.06 , 0.37    ,
  "beta[psa:.trtclassIL blocker]"      , 0.00 , 0.18, -0.35  , 0.00  , 0.37    ,
  "d[ETN]"                              , 1.55 , 0.08, 1.39   , 1.55  , 1.72    ,
  "d[IXE_Q2W]"                          , 2.95 , 0.09, 2.79   , 2.95  , 3.13    ,
  "d[IXE_Q4W]"                          , 2.54 , 0.08, 2.38   , 2.54  , 2.71    ,
  "d[SEC_150]"                          , 2.14 , 0.11, 1.93   , 2.14  , 2.37    ,
  "d[SEC_300]"                          , 2.45 , 0.12, 2.22   , 2.45  , 2.69    )

summary_fe <- summary(pso_fit_FE, pars = c("beta", "d")) %>% 
  as_tibble() %>% 
  select(parameter, mean, sd, `2.5%`, `50%`, `97.5%`)

test_that("FE model parameters", {
  expect_equal(summary_fe, test_fe, tolerance = tol, check.attributes = FALSE)
})

# FE DIC
test_that("FE DIC", {
  expect_equivalent(pso_dic_FE$resdev, 3129.4, tolerance = tol_dic)
  expect_equivalent(pso_dic_FE$pd, 24.1, tolerance = tol_dic)
  expect_equivalent(pso_dic_FE$dic, 3153.5, tolerance = tol_dic)
})

# Population average relative effects in target population
test_releff_fe_new <- tribble(
  ~parameter         , ~mean, ~sd , ~`2.5%`, ~`50%`, ~`97.5%`,
  "d[New 1: ETN]"    , 1.25 , 0.24, 0.81 , 1.24, 1.73  ,
  "d[New 1: IXE_Q2W]", 2.89 , 0.23, 2.46 , 2.88, 3.36  ,
  "d[New 1: IXE_Q4W]", 2.48 , 0.23, 2.05 , 2.47, 2.94  ,
  "d[New 1: SEC_150]", 2.08 , 0.23, 1.64 , 2.07, 2.55  ,
  "d[New 1: SEC_300]", 2.39 , 0.23, 1.95 , 2.38, 2.86  )

summary_releff_fe_new <- pso_releff_FE_new %>% 
  as_tibble() %>% 
  select(parameter, mean, sd, `2.5%`, `50%`, `97.5%`)

test_that("FE PATE in target population", {
  expect_equal(summary_releff_fe_new, test_releff_fe_new, tolerance = tol, check.attributes = FALSE)
})

# Check construction of all contrasts
pso_releff_FE_all_contr <- relative_effects(pso_fit_FE, all_contrasts = TRUE)

# Reconstruct from basic contrasts in each study
dk <- function(study, trt, sims = pso_releff_FE$sims) {
  if (trt == "PBO") return(0)
  else return(sims[ , , paste0("d[", study, ": ", trt, "]"), drop = FALSE])
}

test_all_contr <- tibble(
  contr = pso_releff_FE_all_contr$summary$parameter,
  study = factor(stringr::str_extract(contr, "(?<=\\[)(.+)(?=:)")),
  trtb = stringr::str_extract(contr, "(?<=\\: )(.+)(?= vs\\.)"),
  trta = stringr::str_extract(contr, "(?<=vs\\. )(.+)(?=\\])")
) %>% 
  rowwise() %>% 
  mutate(as_tibble(multinma:::summary.mcmc_array(dk(study, trtb) - dk(study, trta)))) %>% 
  select(.study = study, parameter = contr, mean:Rhat)

test_that("Construction of all contrasts is correct", {
  expect_equal(pso_releff_FE_all_contr$summary, test_all_contr, check.attributes = FALSE)
})

# Check all contrasts in target population
pso_releff_FE_all_contr_new <- relative_effects(pso_fit_FE, newdata = new_agd_means, all_contrasts = TRUE)

test_all_contr_new <- tibble(
  contr = pso_releff_FE_all_contr_new$summary$parameter,
  study = factor(stringr::str_extract(contr, "(?<=\\[)(.+)(?=:)")),
  trtb = stringr::str_extract(contr, "(?<=\\: )(.+)(?= vs\\.)"),
  trta = stringr::str_extract(contr, "(?<=vs\\. )(.+)(?=\\])")
) %>% 
  rowwise() %>% 
  mutate(as_tibble(multinma:::summary.mcmc_array(dk(study, trtb, pso_releff_FE_new$sims) - dk(study, trta, pso_releff_FE_new$sims)))) %>% 
  select(.study = study, parameter = contr, mean:Rhat)

test_that("Construction of all contrasts in target population is correct", {
  expect_equal(pso_releff_FE_all_contr_new$summary, test_all_contr_new, check.attributes = FALSE)
})

# Population average response probabilities in target population
test_pred_fe_new <- tribble(
  ~parameter            , ~mean, ~sd , ~`2.5%`, ~`50%`, ~`97.5%`,
  "pred[New 1: PBO]"    , 0.06 , 0.03, 0.02   , 0.06  , 0.12    ,
  "pred[New 1: ETN]"    , 0.37 , 0.06, 0.26   , 0.37  , 0.48    ,
  "pred[New 1: IXE_Q2W]", 0.90 , 0.03, 0.84   , 0.90  , 0.94    , 
  "pred[New 1: IXE_Q4W]", 0.81 , 0.04, 0.72   , 0.81  , 0.88    ,
  "pred[New 1: SEC_150]", 0.68 , 0.06, 0.57   , 0.68  , 0.78    ,
  "pred[New 1: SEC_300]", 0.78 , 0.05, 0.68   , 0.78  , 0.86    )

summary_pred_fe_new <- pso_pred_FE_new %>% 
  as_tibble() %>% 
  select(parameter, mean, sd, `2.5%`, `50%`, `97.5%`)

test_that("FE average response probabilities in target population", {
  expect_equal(summary_pred_fe_new, test_pred_fe_new, tolerance = tol, check.attributes = FALSE)
})
```
